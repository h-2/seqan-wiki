
== SeqAn C++ Code Style ==
[[TOC()]]

The aim of this style guide is to enforce a certain level of canonicality on all SeqAn code.
Besides good comments, having a common style guide is the key to being able to understand and change code written by others easily.

(The style guide partially follows the [http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml Google C++ Code Style Guide].)

=== C++ Features ===

==== Reference Arguments ====

We prefer reference arguments over pointer arguments.
Use <tt>const</tt> where possible.

{| border=1 class="simple"
!, !) ====
|}


<pre>
#FoldOut
{| border=1 class="simple"
!</tt>, and <tt>!</tt> instead of <tt>and</tt>, <tt>or</tt>, and <tt>not</tt>.
|}

----
While available from C++98, MSVC does not support them out of the box, a special header <tt><iso646.h></tt> has to be included.
Also, they are unfamiliar to most C++ programmers and nothing in SeqAn is using them.
</pre>

==== Default Arguments ====

<pre>
#FoldOut
Default arguments to global functions are problematic with generated forwards.
They can be replaced with function overloading, so do not use them.
----
You can replace default arguments with function overloading as follows.
Do not do this.

<pre>
#cpp
inline double f(int x, double y = 1.0)
{
    // ...
}
</pre>

Do this instead.

<pre>
#cpp
inline double f(int x, double y)
{
    // ...
}

inline double f(int x)
{
    return f(x, 1.0);
}
</pre>
</pre>

==== Exceptions ====

<pre>
#FoldOut
Currently, the SeqAn code does not use any exceptions and is not exception safe.
Do not use any exceptions yourself, instead use return codes.
----
The following is an example where two chars are read using <tt><cstdio></tt> I/O.
We use a return code of <tt>0</tt> to indicate no errors.

<pre>
#cpp
int readSome(char & c, FILE * fp)
{
    int res = fgetc(fp);
    if (res < 0)
        return res;
    res = fgetc(fp);
    if (res < 0)
        return res;
    c = res;
    return 0;
}
</pre>
</pre>

==== Virtual Member Functions ====

Do not use virtual member functions:
Since we mostly use template subclassing instead of C++ built-in subclassing, there rarely is the need for member functions.
In the case where there are member functions, they should not be <tt>virtual</tt> since this is slow when used in tight loops.

==== <tt>static_cast<></tt> ====

Prefer <tt>static_cast<></tt> over C-style casts.

==== <tt>const_cast<></tt> ====

<pre>
#FoldOut
Use const-casts only to make an object const, do not remove consts.SANDBOX_ARG_PARSE
Rather, use the <tt>mutable</tt> keyword on selected members.
<tt>const_cast<></tt> is allowed for interfacing with external (C) APIs where the <tt>const</tt> keyword is missing but which do not modify the variable.
----
The following is an example where <tt>const_cast<></tt> is OK:

<pre>
#cpp
template <typename T>
bool isXyz(T const & x)
{
    return x._member == 0;
}

template <typename T>
bool isXyz(T & x)
{
    return const_cast<T const &>(x)._member == 0;
}
</pre>
</pre>

==== <tt>reinterpret_cast<></tt> ====

Only use <tt>reinterpret_cast<></tt> when you absolutely have to and you know what you are doing!
Sometimes, it is useful for very low-level code but mostly it indicates a design flaw.

==== pre/post increment/decrement ====

<pre>
#FoldOut
Prefer the "pre" variants for decrement and increment, especially in loops.
Their advantage is that no copy of an object has to be made.
----
Good:

<pre>
#cpp
typedef Iterator<TContainer>::Type TIterator;
for (TIterator it = begin(container); atEnd(it); ++it)
{
    // do work
}
</pre>

Bad:

<pre>
#cpp
typedef Iterator<TContainer>::Type TIterator;
for (TIterator it = begin(container); atEnd(it); it++)
{
    // do work
}
</pre>
</pre>

=== Code Quality ===

==== Const-Correctness ====

Write const correct code.
Read the [http://www.parashift.com/c++-faq-lite/const-correctness.html C++ FAQ const correctness article] for more information.
Besides other things, this allows to use temporary objects without copying in functions that do not need to change their arguments.

==== Compiler Warnings ====

<pre>
#FoldOut
All code in the ''core'' and ''extras'' repository must compile without any warnings using the flags generated by the CMake system.
----
Currently, the GCC flags are:

<pre>
-W -Wall -Wstrict-aliasing -pedantic -Wno-long-long -Wno-variadic-macros
</pre>
</pre>

==== Style Conformance ====

Follow this code style whenever possible.
However, prefer consistency over conformance.

If you are editing code that is non-conforming consider whether you could/should adapt the whole file to the new style.
If this is not feasible, prefer consistency over conformance.

=== Semantics ===

==== Parameter Ordering ====

<pre>
#FoldOut
The general parameter order should be (1) output, (2) non-const input (e.g. file handles), (3) input, (4) tags.
Within these groups, the order should be from mandatory to optional.
----
In SeqAn, we read functions <tt>f(out1, out2, out3, ..., in1, in2, in3, ...)</tt> as <tt>(out1, out2, out3, ...) <- f(in1, in2, in3, ...)</tt>.

E.g. <tt>assign()</tt>:

<pre>
#cpp
template <typename T>
void f(T & out, T const & in)
{
    out = in;
}
</pre>
</pre>

=== Scoping, Helper Code ===

==== Global Variables ====

Do not use global variables.
They introduce hard-to find bugs and require the introduction of a link-time library.

==== Tags In Function Arguments ====

<pre>
#FoldOut
Tags in function arguments should always be const.
----
<pre>
#cpp
// somewhere in your code:

struct Move_;
typedef Tag<Move_> Move;

// then, later:

void appendValue(TContainer, Move const &)
{
    // ...
}
</pre>
</pre>

=== Structs and Classes ===

==== Visibility Specifiers ====

<pre>
#FoldOut
Visibility specifiers should go on the same indentation level as the <tt>class</tt> keyword.
----
Example:

<pre>
#cpp
class MyStruct
{
public:
protected:
private:
};
</pre>
</pre>

==== Tag Definitions ====

<pre>
#FoldOut
Tags that are possibly also used in other modules must not have additional parameters and be defined using the <tt>Tag<></tt> template.
Tags that have parameters must only be used within the module they are defined in and have non-generic names.
----
Tags defined with the <tt>Tag<></tt> template and a typedef can be defined multiply.
These definitions must have the following pattern:

<pre>
#cpp
struct TagName_;
typedef Tag<TagName_> TagName;
</pre>

This way, there can be multiple definitions of the same tag since the struct <tt>TagName_</tt> is only declared but not defined and there can be duplicate typedefs.

For tags (also those used for specialization) that have template parameters, the case is different.
Here, we cannot wrap them inside the <tt>Tag<></tt> template with a typedef since it still depends on parameters.
Also we want to be able to instantiate tags so we can pass them as function arguments.
Thus, we have to add a struct body and thus define the struct.
There cannot be multiple identical definitions in C++.
Thus, each tag with parameters must have a unique name throughout SeqAn.
Possibly too generic names should be avoided.
E.g. <tt>Chained</tt> should be reserved as the name for a global tag but <tt>ChainedFile<></tt> can be used as a specialization tag in a file-related module.

Note that this restriction does not apply for internally used tags (e.g. those that have an underscore postfix) since these can be renamed without breaking the public API.
</pre>

==== In-Place Member Functions ====

<pre>
#FoldOut
Whenever possible, functions should be declared and defined outside the class.
The constructor, destructor and few operators have to be defined inside the class, however.
----
The following has to be defined and declared within the class (also see [http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B Wikipedia]):

*constructors
*destructors
*function call operator <tt>operator()</tt>
*type cast operator <tt>operator T()</tt>
*array subscript operator <tt>operator[]()</tt>
*dereference-and-access-member operator <tt>operator->()</tt>
*assignment operator <tt>operator=()</tt>
</pre>

=== Formatting ===

==== Constructor Initialization Lists ====

<pre>
#FoldOut
If the whole function prototype fits in one line, keep it in one line.
Otherwise, wrap line after column and put each argument on its own line indented by one level.
Align the initialization list.
----
Example:

<pre>
#cpp
class Class
{
    MyClass() :
        member1(0),
        member2(1),
        member3(3)
    {}
};
</pre>
</pre>

==== Line Length ====

The maximum line length is 120.
Use a line length of 80 for header comments and the code section separators.

==== Non-ASCII Characters ====

<pre>
#FoldOut
All files should be UTF-8, non-ASCII characters should not occur in them nevertheless.
----
In comments, use <tt>ss</tt> instead of <tt>ß</tt> and <tt>ae</tt> instead of <tt>ä</tt> etc.

In strings, use UTF-8 coding. For example, <tt>"\xEF\xBB\xBF"</tt> is the Unicode zero-width no-break space character, which would be invisible if included in the source as straight UTF-8.
</pre>

==== Spaces VS Tabs ====

<pre>
#FoldOut
Do not use tabs, use spaces.
Use <tt>"\t"</tt> in strings instead of plain tabs.
----
After some discussion, we settled on this.
All programmer's editors can be configured to use spaces instead of tabs.
We use a four spaces to a tab.

There can be problems when indenting in for loops with tabs, for example.
Consider the following (<tt>-->|</tt> is a tab, <tt>_</tt> is a space):

<pre>
#cpp
for (int i = 0, j = 0, k = 0, ...;
<u>_</u>cond1 && cond2 &&; ++i)
{
  // ...
}
</pre>

Here, indentation can happen up to match the previous line.
Mixing tabs and spaces works, too.
However, since tabs are not shown in the editor, people might indent a file with mixed tabs and spaces with spaces if they are free to mix tabs and spaces.

<pre>
#cpp
for (int i = 0, j = 0, k = 0, ...;
-->|_cond1 && cond2 &&; ++i)
{
  // ...
}
</pre>
</pre>

==== Indentation ====

We use an indentation of four spaces per level.

<pre>#FoldOut
Note that '''namespaces do not cause an increase in indentation level.'''
----
<pre>#cpp
namespace seqan {

class SomeClass
{
};

}  // namespace seqan
</pre>
</pre>

==== Trailing Whitespace ====

<pre>
#FoldOut
Trailing whitespace is forbidden.
----
Trailing whitespace is not visible, leading whitespace for indentation is perceptible through the text following it.
Anything that cannot be seen can lead to "trash changes" in the SVN when somebody accidently removes it.
</pre>

==== Inline Comments ====

<pre>
#FoldOut
Use inline comments to document variables.
----
Possibly align inline comments.

<pre>
#cpp
short x;    // a short is enough!
int myVar;  // this is my variable, do not touch it
</pre>
</pre>

==== Brace Positions ====

<pre>
#FoldOut
Always put brace positions on the next line.
----
<pre>
#cpp
class MyClass
{
public:
    int x;

    MyClass() : x(10)
    {}
};

void foo(char c)
{
    switch (c)
    {
    case 'X':
        break;
    }
    // ...
}
</pre>
</pre>

==== Conditionals ====

<pre>
#FoldOut
Use no spaces inside the parantheses, the <tt>else</tt> keyword belongs on a new line, use block braces consistently.
----
Conditional statements should look like this:

<pre>
#cpp
if (a == b)
{
    return 0;
}
else if (c == d)
{
    int x = a + b + d;
    return x;
}

if (a == b)
    return 0;
else if (c == d)
    return a + b + d;
</pre>

Do not leave out the spaces before and after the parantheses, do not put leading or trailing space in the paranthesis.
The following is wrong:

<pre>
#cpp
if (foo){
    return 0;
}
if(foo)
    return 0;
if (foo ) 
    return 0;
</pre>

Make sure to add braces to all blocks if any block has one.
The following is wrong:

<pre>
#cpp
if (a == b)
    return 0;
else if (c == d)
{
    int x = a + b + d;
    return x;
}
</pre>
</pre>

==== Loops and Switch Statements ====

<pre>
#FoldOut
Switch statements may use braces for blocks.
Empty loop bodies should use <tt>{}</tt> or <tt>continue</tt>.
----
Format your switch statements as follows.
The usage of blocks is optional.
Blocks can be useful for declaring variables inside the switch statement.

<pre>
#cpp
switch (var)
{
case 0:
    return 1;
case 1:
    return 0;
default:
    SEQAN_FAIL("Invalid value!");
}

switch (var2)
{
case 0:
    return 1;
case 1:
{
    int x = 0;
    for (int i = 0; i < var3; ++i)
        x ++ i;
    return x;
}
default:
    SEQAN_FAIL("Invalid value!");
}
</pre>

Empty loop bodies should use <tt>{}</tt> or <tt>continue</tt>, but not a single semicolon.

<pre>
#cpp
while (condition)
{
  // Repeat test until it returns false.
}

for (int i = 0; i < kSomeNumber; ++i)
    {}  // Good - empty body.
while (condition)
    continue;  // Good - continue indicates no logic.
</pre>
</pre>

==== Expressions ====

<pre>
#FoldOut
Binary expressions are surrounded by one space. Unary expressions are preceded by one space.
----
Example:

<pre>
#cpp
{| border=1 class="simple"
! c == d 
! e == f 
! x)
|}

{
    // ...
}

bool y = x;
unsigned i = ~j;
</pre>
</pre>

==== Type Expressions ====

<pre>
#FoldOut
No spaces around period or arrow.
Add spaces before and after pointer and references.
<tt>const</tt> comes after the type.
----
The following are good examples:

<pre>
#cpp
int x = 0;
int * ptr = x;                     // OK, spaces are good.
int const & ref = x;               // OK, const after int
int main(int argc, char ** argv);  // OK, group pointers.
</pre>

Bad Examples:

<pre>
#cpp
int x = 0;
int* ptr = x;         // bad spaces
int *ptr = x;         // bad spaces
const int & ref = x;  // wrong placement of const
int x = ptr -> z;     // bad spaces
int x = obj. z;       // bad spaces
</pre>
</pre>

==== Function Return Types ====

<pre>
#FoldOut
If a function definition is short, everything is on the same line. Otherwise, split.
----
Good example:

<pre>
#cpp
int foo();

template <typename TString>
typename Value<TString>::Type
anotherFunction(TString const & foo, TString const & bar, /*...*/)
{
    // ...
}
</pre>
</pre>

==== Inline Functions ====

<pre>
#FoldOut
If a function definition is short, everything is on the same line. Otherwise put inline and return type in the same line.
----
Good example:

<pre>
#cpp
inline int foo();

template <typename TString>
inline typename Value<TString>::Type
anotherFunction(TString const & foo, TString const & bar, /*...*/)
{
    // ...
}
</pre>
</pre>

==== Function Argument Lists ====

<pre>
#FoldOut
If it fits in one line, keep in one line.
Otherwise, wrap at the paranthesis, put each argument on its own line.
For very long function names and parameter lines, break after opening bracket.
----
Good example:

<pre>
#cpp
template <typename TA, typename TB>
inline void foo(TA & a, TB & b);

template </*...*/>
inline void foo2(TA & a,
                 TB & b,
                 ...
                 TY & y,
                 TZ & z);

template </*...*/>
inline void _functionThisIsAVeryVeryLongFunctionNameSinceItsAHelper(
    TThisTypeWasMadeToForceYouToWrapInTheLongNameMode & a,
    TB & b,
    TC & c,
    TB & d,
    ...);
</pre>
</pre>

==== Template Argument Lists ====

<pre>
#FoldOut
Follow conventions of function parameter lists, no blank after opening <tt><</tt>.
----
As for function parameters, try to fit everything on one line if possible, otherwise, break the template parameters over multiple lines and put the commas directly after the type names.
<pre>
#cpp
template <typename T1, typename T1>
void foo() {}

template <typename T1, typename T2, ...
          typename T10, typename T11>
void bar() {}
</pre>

Multiple closing <tt>></tt> go to the same line and are only separated by spaces if two closing angular brackets come after each other.

<pre>
#cpp
typedef Iterator<Value<TValue>::Type,
                 Standard> ::Type

typedef String<char, Alloc<> > TMyString
// -------------------------^
</pre>
</pre>

==== Function Calls ====

<pre>
#FoldOut
Similar rules as in [#FunctionArgumentLists Function Argument Lists] apply.
When wrapped, not each parameter has to occur on its own line.
----
Example:
<pre>
#cpp
foo(a, b);

foo2(a, b, c, ...
     x, y, z);

if (x)
{
    if (y)
    {
        _functionThisIsAVeryVeryLongFunctionNameSinceItsAHelper(
            firstParameterWithALongName, b, c, d);
    }
}
</pre>
</pre>

=== Naming Rules ===

In the following, camel case means that the first letter of each word is written upper case, the remainder is written in lower case.
Abbreviations of length 2 are kept in upper case, longer abbreviations are camel-cased.

==== Macros ====

<pre>
#FoldOut
Macros are all upper case, separated by underscores, prefixed with <tt>SEQAN_</tt>.
----
Example:

<pre>
#cpp
SEQAN_ASSERT_EQ(val1, val2);

#define SEQAN_MY_TMP_MACRO(x) f(x)
// ...
SEQAN_MY_TMP_MACRO(1);
// ...
#undef SEQAN_MY_TMP_MACRO
</pre>
</pre>

==== Variable Naming ====

<pre>
#FoldOut
Variables are named in camel case, starting with a lower-case parameter.
Internal member variables have an underscore prefix.
----
Example:

<pre>
#cpp
int x;
int myVar;
int saValue(/*...*/);
int getSAValue(/*...*/);

struct FooBar
{
    int _x;
};
</pre>
</pre>

==== Constant / Enum Value Naming ====

<pre>
#FoldOut
Constant and enum values are named like macros: All-upper case, separated by dashes.
----
Example:

<pre>
#cpp
enum MyEnum
{
    MY_ENUM_VALUE1 = 1,
    MY_ENUM_VALUE2 = 20
};

int const MY_VAR = 10;
</pre>
</pre>

==== Struct / Enum / Class Naming ====

<pre>
#FoldOut
Types are written in camel case, starting with an upper case character.
----
Internal library types have an underscore suffix.

Example:

<pre>
#cpp
struct InternalType_
{};

struct SAValue
{};

struct LcpTable
{};
</pre>
</pre>

==== Metafunction Naming ====

<pre>
#FoldOut
Metafunctions are named like structs, defined values are named <tt>VALUE</tt>, types <tt>Type</tt>.
----
Metafunctions should not export any other types or values publically, e.g. they should have an underscore suffix.

Example:

<pre>
#cpp
template <typename T>
struct MyMetaFunction
{
    typedef typename RemoveConst<T>::Type TNoConst_;
    typedef TNonConst_ Type;
};

template <typename T>
struct MyMetaFunction2
{
    typedef True Type;
    static bool const VALUE = false;
};
</pre>
</pre>

==== Function Naming ====

<pre>
#FoldOut
The same naming rule as for variables applies.
----
Example:

<pre>
#cpp
void fooBar();

template <typename T>
int saValue(T & x);

template <typename T>
void lcpTable(T & x);
</pre>
</pre>

==== Names In Documentation ====

In the documentation, classes have the same name as in the source code, e.g. the class StringSet is documented as "class StringSet."
Specializations are named "<tt>$SPEC $CLASS</tt>", e.g. "Concat StringSet", "Horspool Finder."

=== Comments ===

==== File Comments ====

<pre>
#FoldOut
Each file should begin with a file header.
----
The file header has the format.
The ''skel.py'' tool automatically generates files with appropriate headers.

<pre>
#cpp
// ==========================================================================
//                              $PROJECT NAME
// ==========================================================================
// Copyright (C) 2010 $AUTHOR, $ORGANIZATION
//
// $LICENSE
//
// ==========================================================================
// Author: $NAME <$EMAIL>
// ==========================================================================
// $FILE_DESCRIPTION
// ==========================================================================
</pre>
</pre>

==== Class, Function, Metafunction, Enum, Macro DDDoc Comments ====

<pre>
#FoldOut
Each public class, function, metafunction, enum, and macro should be documented using [[HowTo/DocumentCode| DDDoc]].
Internal code should be documented, too.
----
Example:

<pre>
#cpp
/**
.Class.IntervalAndCargo:
..cat:Miscellaneous
..summary:A simple record type that stores an interval and a cargo value.
..signature:IntervalAndCargo<TValue, TCargo>
..param.TValue:The value type, that is the type of the interval borders.
...default:int.
...metafunction:Metafunction.Value
..param.TCargo:The cargo type.
...default:int.
...metafunction:Metafunction.Cargo
..include:seqan/refinement.h
*/

template <typename TValue = int, typename TCargo = int>
class IntervalAndCargo
{
// ...
};

// This functions helps the XYZ class to fulfill the ABC functionality.
//
// It corresponds to function FUNC() in the paper describing the original
// algorithm.  The variables in this function correspond to the names in the
// paper and thus the code style is broken locally.

void _helperFunction(/*...*/)
{}
</pre>
</pre>

==== Implementation Comments ====

All functions etc. should be well-documented.
In most cases, it is more important how something is done instead of of what is done.

==== TODO Comments ====

TODO comments have the format <tt>// TODO($USERNAME): $TODO_COMMENT</tt>.
The username is the username of the one writing the item, not the one to fix it.
Use tickets for this.

=== Source Tree Structure ===

==== File Name Rules ====

<pre>
#FoldOut
File and directories are named all-lower case, words are separated by underscores.
----
Exceptions are ''INFO'', ''COPYING'', ''README'', ... files.

Examples:

*''string_base.h''
*''string_packed.h''
*''suffix_array.h''
*''lcp_table.h''
</pre>

==== Overall Structure ====

Can be found in wiki:WhitePapers/RepositoryStructure for now.

==== Repositories ====

Can be found in wiki:WhitePapers/RepositoryStructure for now.

==== Library Modules ====

Can be found in wiki:WhitePapers/RepositoryStructure for now.

==== Tests ====

Can be found in wiki:WhitePapers/RepositoryStructure for now.

==== Demos ====

Can be found in wiki:WhitePapers/RepositoryStructure for now.

==== Apps ====

Can be found in wiki:WhitePapers/RepositoryStructure for now.

=== File Structure ===

==== Header <tt>#define</tt> guard ====

<pre>
#FoldOut
The header <tt>#define</tt> include guards are constructed from full paths to the repository root.
----
Example:

{| border=1 class="simple"
! '''filename''' 
! '''preprocessor symbol'''
|- 
|  seqan/core/include/seqan/basic/iterator_base.h 
|  <tt>SEQAN_CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_</tt> 
|}


<pre>
#cpp
#ifndef SEQAN_CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_ 
#define SEQAN_CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_ 
#endif  // #ifndef SEQAN_CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_ 
</pre>
</pre>

==== Include Order ====

The include order should be (1) standard library requirements, (2) external requirements, (3) required SeqAn modules.

In SeqAn module headers (e.g. ''basic.h''), then all files in the module are included.

==== CPP File Structure ====

<pre>
#cpp
// ==========================================================================
//                                $APP_NAME
// ==========================================================================
// Copyright (c) 2006-2011, Knut Reinert, FU Berlin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Knut Reinert or the FU Berlin nor the names of
//       its contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL KNUT REINERT OR THE FU BERLIN BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
// DAMAGE.
//
// ==========================================================================
// Author: $AUTHOR_NAME <$AUTHOR_EMAIL>
// ==========================================================================
// $FILE_COMMENT
// ==========================================================================

#include <seqan/basic.h>
#include <seqan/sequence.h>

#include <seqan/misc/misc_cmdparser.h>

#include "app_name.h"

using namespace seqan;

// Program entry point
int main(int argc, char const ** argv)
{
    // ...
}
</pre>

==== Application Header Structure ====

<pre>
#cpp
// ==========================================================================
//                                $APP_NAME
// ==========================================================================
// Copyright (c) 2006-2010, Knut Reinert, FU Berlin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Knut Reinert or the FU Berlin nor the names of
//       its contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL KNUT REINERT OR THE FU BERLIN BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
// DAMAGE.
//
// ==========================================================================
// Author: $AUTHOR_NAME <$AUTHOR_EMAIL>
// ==========================================================================
// $FILE_COMMENT
// ==========================================================================

#ifndef CORE_APPS_APP_NAME_HEADER_FILE_H_
#define CORE_APPS_APP_NAME_HEADER_FILE_H_

// ==========================================================================
// Forwards
// ==========================================================================

// ==========================================================================
// Tags, Classes, Enums
// ==========================================================================

// --------------------------------------------------------------------------
// Class ClassName
// --------------------------------------------------------------------------

// ==========================================================================
// Metafunctions
// ==========================================================================

// --------------------------------------------------------------------------
// Metafunction MetafunctionName
// --------------------------------------------------------------------------

// ==========================================================================
// Functions
// ==========================================================================

// --------------------------------------------------------------------------
// Function functionName()
// --------------------------------------------------------------------------

#endif  // CORE_APPS_APP_NAME_HEADER_FILE_H_
</pre>

==== Library Header Structure ====

<pre>
#cpp
// ==========================================================================
//                 SeqAn - The Library for Sequence Analysis
// ==========================================================================
// Copyright (c) 2006-2010, Knut Reinert, FU Berlin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Knut Reinert or the FU Berlin nor the names of
//       its contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL KNUT REINERT OR THE FU BERLIN BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
// DAMAGE.
//
// ==========================================================================
// Author: AUTHOR NAME <AUTHOR EMAIL>
// ==========================================================================
// SHORT COMMENT ON WHAT THIS FILE CONTAINS
// ==========================================================================

#ifndef CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_
#define CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_

namespace seqan {

// ==========================================================================
// Forwards
// ==========================================================================

// ==========================================================================
// Tags, Classes, Enums
// ==========================================================================

// --------------------------------------------------------------------------
// Class ClassName
// --------------------------------------------------------------------------

// ==========================================================================
// Metafunctions
// ==========================================================================

// --------------------------------------------------------------------------
// Metafunction MetafunctionName
// --------------------------------------------------------------------------

// ==========================================================================
// Functions
// ==========================================================================

// --------------------------------------------------------------------------
// Function functionName()
// --------------------------------------------------------------------------

}  // namespace seqan

#endif  // CORE_INCLUDE_SEQAN_BASIC_ITERATOR_BASE_H_
</pre>



{{TracNotice|{{PAGENAME}}}}